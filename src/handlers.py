\n\"\"\"\nAsynchronous command handlers for the Telegram bot.\nAll handlers must be `async` and use the async `db` module.\n\"\"\"\nimport logging\nfrom telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import ContextTypes\nfrom telegram.constants import ParseMode\nfrom telegram.error import BadRequest\n\nfrom . import db\n\nlogger = logging.getLogger(__name__)\n\n# === Utility Functions ===\n\nasync def get_user_id(update: Update) -> int | None:\n    \"\"\"Extracts user ID from an update.\"\"\"\n    if update.effective_user:\n        return update.effective_user.id\n    return None\n\ndef build_settings_keyboard(settings: dict) -> InlineKeyboardMarkup:\n    \"\"\"Builds the dynamic settings keyboard with current values.\"\"\"\n    keyboard = []\n    setting_order = [\n        \'autotrade\', \'trading_mode\', \'rsi_buy\', \'rsi_sell\', \'stop_loss\',\n        \'trailing_activation\', \'trailing_drop\', \'profit_target\', \'paper_balance\', \'watchlist\'\n    ]\n\n    for key in setting_order:\n        value = settings.get(key)\n        # Truncate long watchlist for display\n        if key == \'watchlist\':\n            display_value = f\": {value[:30]}...\" if value and len(value) > 30 else f\": {value}\"\n        else:\n            display_value = f\': {value}\' if value is not None else \'\'\n\n        if key == \'autotrade\':\n            action = \'off\' if value == \'on\' else \'on\'\n            button_text = f\"Auto-Trading: {\'âœ… ON\' if value == \'on\' else \'âŒ OFF\'}\"\n            callback_data = f\"set:{key}:{action}\"\n        elif key == \'trading_mode\':\n            action = \'PAPER\' if value == \'LIVE\' else \'LIVE\'\n            button_text = f\"Mode: {\'ðŸ’µ LIVE\' if value == \'LIVE\' else \'ðŸ“„ PAPER\'}\"\n            callback_data = f\"set:{key}:{action}\"\n        else:\n            button_text = f\"{key.replace(\'_\', \' \').title()}{display_value}\"\n            callback_data = f\"prompt:{key}\"\n\n        keyboard.append([InlineKeyboardButton(button_text, callback_data=callback_data)])\n\n    keyboard.append([InlineKeyboardButton(\"Done\", callback_data=\"settings_done\")])\n    return InlineKeyboardMarkup(keyboard)\n\n# === Core Command Handlers ===\n\nasync def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Greets the user and sets up their account.\"\"\"\n    user_id = await get_user_id(update)\n    if not user_id: return\n\n    logger.info(f\"User {user_id} ({update.effective_user.full_name}) started the bot.\")\n    _, created = await db.get_or_create_user(user_id)\n\n    welcome_message = (\n        \"Welcome to the Empire, Commander. Your command center is ready.\"\n        if created else\n        \"Welcome back, Commander. Your legions await your command.\"\n    )\n    await update.message.reply_text(f\"{welcome_message}\\n\\nUse /status or /myprofile to see your configuration.\")\n\nasync def status_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Displays the user\'s current settings and open trades.\"\"\"\n    user_id = await get_user_id(update)\n    if not user_id: return\n\n    settings = await db.get_user_effective_settings(user_id)\n    open_trades = await db.get_open_trades_by_user(user_id)\n\n    status_text = \"*Your Imperial Command Center*\\n\\n\"\n    status_text += \"*Strategic Settings:*\\n\"\n    for key, value in settings.items():\n        key_name = key.replace(\'_\', \' \').title()\n        # Escape characters for MarkdownV2. This is important.\n        value_str = str(value).replace(\'.\', r\'\\\.\').replace(\'-\', r\'\\\-\').replace(\'!\', r\'\\!\')\n        status_text += f\"- *{key_name}*: `{value_str}`\\n\"\n\n    if open_trades:\n        status_text += \"\\n*Active Campaigns (Open Trades):*\\n\"\n        for trade in open_trades:\n             status_text += f\"- `{trade[\'symbol\']}` @ ${trade[\'buy_price\']:,.4f}\\n\"\n    else:\n        status_text += \"\\n*No active campaigns at this time.*\\n\"\n\n    await update.message.reply_text(status_text, parse_mode=ParseMode.MARKDOWN_V2)\n\nasync def myprofile_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Alias for the /status command.\"\"\"\n    await status_command(update, context)\n\nasync def settings_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Displays the settings management keyboard.\"\"\"\n    user_id = await get_user_id(update)\n    if not user_id: return\n\n    settings = await db.get_user_effective_settings(user_id)\n    keyboard = build_settings_keyboard(settings)\n    await update.message.reply_text(\"Choose a setting to adjust, or select a toggle:\", reply_markup=keyboard)\n\nasync def settings_callback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Handles all inline keyboard interactions for settings.\"\"\"\n    query = update.callback_query\n    await query.answer()\n    user_id = await get_user_id(update)\n    if not user_id: return\n\n    parts = query.data.split(\':\')\n    action = parts[0]\n\n    if action == \'settings_done\':\n        await query.edit_message_text(\"Settings saved. The empire adapts to your command.\")\n        return\n\n    setting_key = parts[1]\n\n    if action == \'set\':  # For toggles\n        new_value = parts[2]\n        await db.update_user_setting(user_id, setting_key, new_value)\n        logger.info(f\"User {user_id} updated setting \'{setting_key}\' to \'{new_value}\'.\")\n\n        # Refresh keyboard and gracefully edit the reply markup\n        new_settings = await db.get_user_effective_settings(user_id)\n        keyboard = build_settings_keyboard(new_settings)\n        try:\n            await query.edit_message_reply_markup(reply_markup=keyboard)\n        except BadRequest as e:\n            if \"Message is not modified\" in str(e):\n                logger.warning(\"Settings keyboard was already correct, no modification needed.\")\n            else:\n                raise\n\n    elif action == \'prompt\':\n        context.user_data[\'awaiting_setting\'] = setting_key\n        # Use r-string or escape backslash to avoid SyntaxWarning\n        await query.message.reply_text(f\"Please enter the new value for *{setting_key.replace(\'_\', \' \').title()}*.\", parse_mode=ParseMode.MARKDOWN_V2)\n\nasync def message_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Handles text messages, specifically for updating settings.\"\"\"\n    user_id = await get_user_id(update)\n    if not user_id or \'awaiting_setting\' not in context.user_data:\n        return\n\n    setting_key = context.user_data.pop(\'awaiting_setting\')\n    new_value = update.message.text\n\n    try:\n        await db.update_user_setting(user_id, setting_key, new_value)\n        logger.info(f\"User {user_id} set \'{setting_key}\' to \'{new_value}\'.\")\n        await update.message.reply_text(f\"âœ… *{setting_key.replace(\'_\', \' \').title()}* has been updated.\", parse_mode=ParseMode.MARKDOWN_V2)\n\n        settings = await db.get_user_effective_settings(user_id)\n        keyboard = build_settings_keyboard(settings)\n        await update.message.reply_text(\"Settings updated. Choose another setting or select Done:\", reply_markup=keyboard)\n    except ValueError as e:\n        await update.message.reply_text(str(e))\n    except Exception as e:\n        logger.error(f\"Failed to update setting {setting_key} for user {user_id}: {e}\")\n        await update.message.reply_text(\"An error occurred. The Imperial Guard has been notified.\")\n\nPAYMENT_MESSAGE = \"This is a placeholder for payment information...\"\n\nasync def pay_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Displays the payment information.\"\"\"\n    if update.effective_chat and update.effective_chat.type != \'private\':\n        await update.message.reply_text(\"Please use this command in a private chat.\")\n        return\n    await update.message.reply_html(PAYMENT_MESSAGE)\n\nasync def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Log Errors and handle them gracefully.\"\"\"\n    if isinstance(context.error, BadRequest) and \"Message is not modified\" in str(context.error):\n        logger.warning(f\"Suppressing \'Message is not modified\' error for update: {update}\")\n        return\n\n    logger.error(f\"Exception while handling an update: {context.error}\", exc_info=context.error)\n\n    if isinstance(update, Update) and update.effective_message:\n        try:\n            await update.effective_message.reply_text(\"An internal error occurred. The Imperial Guard has been notified.\")\n        except Exception as e:\n            logger.error(f\"Failed to send error message to user: {e}\")\n